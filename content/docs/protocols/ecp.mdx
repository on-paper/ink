---
title: ECP (Ethereum Comments Protocol)
description: Decentralized comments with signless approvals
---

import { Callout } from 'fumadocs-ui/components/callout';

# ECP Integration

ECP (Ethereum Comments Protocol) enables decentralized, censorship-resistant comments with optional gasless transactions through signless approvals.

## Overview

ECP provides:

- **Decentralized Comments**: Stored on-chain or IPFS
- **Signless Approvals**: Gasless transactions for approved users
- **Moderation Tools**: Community-driven content filtering
- **Threading Support**: Nested conversation structure
- **Cross-platform**: Works across any ECP-enabled platform

## Core Architecture

### Comment Structure

```typescript
interface ECPComment {
  id: string;
  author: string;
  content: string;
  parentId?: string;
  timestamp: number;
  signature: string;
  metadata: {
    likes: number;
    replies: number;
    edited: boolean;
    ipfsHash?: string;
  };
}
```

### Storage Options

1. **On-chain**: Critical comments stored directly
2. **IPFS**: Large comments stored off-chain
3. **Hybrid**: Metadata on-chain, content on IPFS

## Signless Approve Implementation

### How It Works

<Callout type="info">
Signless approval allows approved users to post comments without paying gas fees, significantly improving UX.
</Callout>

```typescript
export async function createSignlessComment(
  content: string,
  parentId?: string
): Promise<string> {
  // Check if user is approved
  const isApproved = await checkSignlessApproval(currentUser);
  
  if (isApproved) {
    // Create signature without blockchain transaction
    const signature = await signMessage({
      content,
      parentId,
      timestamp: Date.now(),
      author: currentUser,
    });
    
    // Submit to gasless relayer
    const commentId = await gaslessSubmitter.submit({
      type: 'CREATE_COMMENT',
      payload: {
        content,
        parentId,
        signature,
      },
    });
    
    return commentId;
  } else {
    // Fall back to regular transaction
    return createRegularComment(content, parentId);
  }
}
```

### Approval Process

```typescript
export async function requestSignlessApproval(): Promise<boolean> {
  // Check eligibility criteria
  const eligible = await checkEligibility(currentUser);
  
  if (!eligible) {
    throw new Error('Not eligible for signless approval');
  }
  
  // Submit approval request
  const tx = await ecpContract.requestApproval({
    user: currentUser,
    proof: generateEligibilityProof(),
  });
  
  await tx.wait();
  
  // Update local state
  setSignlessEnabled(true);
  
  return true;
}
```

### Eligibility Criteria

Users qualify for signless approval based on:

```typescript
interface EligibilityCriteria {
  ensName: boolean;          // Has ENS name
  accountAge: number;        // Days since first transaction
  followerCount: number;     // Minimum followers via EFP
  reputation: number;        // Community reputation score
  stake?: BigNumber;        // Optional stake amount
}

export async function checkEligibility(
  address: string
): Promise<boolean> {
  const criteria = await getCriteria(address);
  
  return (
    criteria.ensName &&
    criteria.accountAge >= 30 &&
    criteria.followerCount >= 10 &&
    criteria.reputation >= 100
  );
}
```

## Gasless Submitter

### Architecture

```typescript
class GaslessSubmitter {
  private queue: Transaction[] = [];
  private processing = false;
  
  async submit(transaction: Transaction): Promise<string> {
    // Validate signature
    const isValid = await this.validateSignature(transaction);
    if (!isValid) {
      throw new Error('Invalid signature');
    }
    
    // Add to queue
    this.queue.push(transaction);
    
    // Process queue
    if (!this.processing) {
      this.processQueue();
    }
    
    return transaction.id;
  }
  
  private async processQueue() {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, 10);
      
      try {
        // Submit batch transaction
        await this.submitBatch(batch);
      } catch (error) {
        // Handle errors and retry
        console.error('Batch submission failed:', error);
        this.queue.unshift(...batch);
      }
    }
    
    this.processing = false;
  }
}
```

### Rate Limiting

```typescript
export class RateLimiter {
  private limits = new Map<string, UserLimit>();
  
  canSubmit(address: string): boolean {
    const limit = this.limits.get(address);
    
    if (!limit) {
      this.limits.set(address, {
        count: 1,
        resetAt: Date.now() + 3600000, // 1 hour
      });
      return true;
    }
    
    if (Date.now() > limit.resetAt) {
      limit.count = 1;
      limit.resetAt = Date.now() + 3600000;
      return true;
    }
    
    if (limit.count < 10) { // 10 comments per hour
      limit.count++;
      return true;
    }
    
    return false;
  }
}
```

## Comment Creation

### Regular Comments

```typescript
export async function createComment(
  content: string,
  parentId?: string
): Promise<string> {
  // Store content on IPFS
  const ipfsHash = await ipfsClient.add(content);
  
  // Create on-chain reference
  const tx = await ecpContract.createComment({
    ipfsHash,
    parentId,
    timestamp: Date.now(),
  });
  
  const receipt = await tx.wait();
  const commentId = extractCommentId(receipt);
  
  // Index locally for fast retrieval
  await indexComment({
    id: commentId,
    content,
    author: currentUser,
    parentId,
    ipfsHash,
  });
  
  return commentId;
}
```

### Rich Media Comments

```typescript
export async function createRichComment(
  content: string,
  media?: File[]
): Promise<string> {
  let mediaUrls: string[] = [];
  
  // Upload media to IPFS
  if (media && media.length > 0) {
    mediaUrls = await Promise.all(
      media.map(file => ipfsClient.uploadFile(file))
    );
  }
  
  // Create structured content
  const richContent = {
    text: content,
    media: mediaUrls,
    formatting: detectFormatting(content),
  };
  
  return createComment(
    JSON.stringify(richContent),
    parentId
  );
}
```

## Comment Retrieval

### Fetching Comments

```typescript
export async function getComments(
  targetId: string,
  options?: CommentOptions
): Promise<ECPComment[]> {
  // Query from indexer
  const comments = await graphClient.query({
    query: GET_COMMENTS,
    variables: {
      targetId,
      limit: options?.limit || 50,
      offset: options?.offset || 0,
    },
  });
  
  // Fetch content from IPFS
  const withContent = await Promise.all(
    comments.map(async (comment) => {
      const content = await ipfsClient.get(comment.ipfsHash);
      return {
        ...comment,
        content,
      };
    })
  );
  
  // Apply client-side filtering
  return filterComments(withContent, options?.filters);
}
```

### Threading Support

```typescript
export function buildCommentTree(
  comments: ECPComment[]
): CommentNode[] {
  const map = new Map<string, CommentNode>();
  const roots: CommentNode[] = [];
  
  // Create nodes
  comments.forEach(comment => {
    map.set(comment.id, {
      ...comment,
      children: [],
    });
  });
  
  // Build tree
  comments.forEach(comment => {
    const node = map.get(comment.id)!;
    
    if (comment.parentId) {
      const parent = map.get(comment.parentId);
      if (parent) {
        parent.children.push(node);
      }
    } else {
      roots.push(node);
    }
  });
  
  return roots;
}
```

## Moderation

### Community Moderation

```typescript
export async function reportComment(
  commentId: string,
  reason: string
): Promise<void> {
  await ecpContract.report({
    commentId,
    reason,
    reporter: currentUser,
  });
  
  // Update local filter
  localFilter.add(commentId);
}

export async function getModeratedComments(
  targetId: string
): Promise<ECPComment[]> {
  const allComments = await getComments(targetId);
  const reports = await getReports(targetId);
  
  // Filter based on community consensus
  return allComments.filter(comment => {
    const reportCount = reports[comment.id]?.length || 0;
    return reportCount < REPORT_THRESHOLD;
  });
}
```

### Personal Filters

```typescript
export class PersonalFilter {
  private blocked = new Set<string>();
  private keywords: string[] = [];
  
  async filterComments(
    comments: ECPComment[]
  ): Promise<ECPComment[]> {
    return comments.filter(comment => {
      // Filter blocked users
      if (this.blocked.has(comment.author)) {
        return false;
      }
      
      // Filter keywords
      const hasBlockedKeyword = this.keywords.some(
        keyword => comment.content.includes(keyword)
      );
      
      if (hasBlockedKeyword) {
        return false;
      }
      
      return true;
    });
  }
}
```

## UI Components

### Comment Box

```tsx
export function CommentBox({ targetId }: Props) {
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const { signlessEnabled } = useECP();
  
  const handleSubmit = async () => {
    setLoading(true);
    
    try {
      if (signlessEnabled) {
        await createSignlessComment(content, targetId);
      } else {
        await createComment(content, targetId);
      }
      
      setContent('');
      // Refresh comments
      mutate(['comments', targetId]);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="border rounded-lg p-4">
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Write a comment..."
        className="w-full p-2 border rounded"
        rows={3}
      />
      
      <div className="flex justify-between mt-2">
        <div className="text-sm text-gray-600">
          {signlessEnabled && (
            <span className="text-green-600">
              âœ“ Gasless enabled
            </span>
          )}
        </div>
        
        <button
          onClick={handleSubmit}
          disabled={loading || !content}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          {loading ? 'Posting...' : 'Post'}
        </button>
      </div>
    </div>
  );
}
```

### Comment Thread

```tsx
export function CommentThread({ comments }: Props) {
  const tree = useMemo(
    () => buildCommentTree(comments),
    [comments]
  );
  
  return (
    <div className="space-y-4">
      {tree.map(node => (
        <CommentNode
          key={node.id}
          comment={node}
          depth={0}
        />
      ))}
    </div>
  );
}

function CommentNode({ comment, depth }: NodeProps) {
  const [collapsed, setCollapsed] = useState(false);
  
  return (
    <div className={`ml-${depth * 4}`}>
      <div className="border-l-2 pl-4">
        <CommentHeader comment={comment} />
        
        {!collapsed && (
          <>
            <CommentContent content={comment.content} />
            
            {comment.children.map(child => (
              <CommentNode
                key={child.id}
                comment={child}
                depth={depth + 1}
              />
            ))}
          </>
        )}
      </div>
    </div>
  );
}
```

## Performance Optimization

### Pagination

```typescript
export function usePaginatedComments(targetId: string) {
  const [page, setPage] = useState(0);
  const pageSize = 20;
  
  const { data, loading } = useQuery({
    queryKey: ['comments', targetId, page],
    queryFn: () => getComments(targetId, {
      limit: pageSize,
      offset: page * pageSize,
    }),
  });
  
  return {
    comments: data || [],
    loading,
    hasMore: data?.length === pageSize,
    loadMore: () => setPage(p => p + 1),
  };
}
```

### Caching Strategy

```typescript
class CommentCache {
  private cache = new LRU<string, ECPComment[]>(100);
  
  async getComments(
    targetId: string,
    force = false
  ): Promise<ECPComment[]> {
    if (!force) {
      const cached = this.cache.get(targetId);
      if (cached) return cached;
    }
    
    const comments = await fetchComments(targetId);
    this.cache.set(targetId, comments);
    
    // Subscribe to updates
    this.subscribeToUpdates(targetId);
    
    return comments;
  }
  
  private subscribeToUpdates(targetId: string) {
    ecpContract.on('CommentCreated', (event) => {
      if (event.targetId === targetId) {
        this.cache.delete(targetId);
      }
    });
  }
}
```

## Best Practices

### Security
- Always validate signatures
- Implement rate limiting
- Sanitize user content
- Use content moderation

### Performance
- Paginate large comment threads
- Cache aggressively
- Use optimistic updates
- Lazy load nested comments

### User Experience
- Show gasless status clearly
- Provide fallback for failures
- Implement real-time updates
- Support rich formatting