---
title: Grove - Lens Storage Client
description: Decentralized storage solution for Lens Protocol integration
---

import { Callout } from 'fumadocs-ui/components/callout';

# Grove Storage Client

Grove is Paper's integrated storage client specifically designed for Lens Protocol compatibility, providing a seamless bridge between decentralized storage solutions and the Lens ecosystem.

## Overview

Grove serves as a unified storage layer that:

- **Lens-native Integration**: Optimized for Lens Protocol metadata standards
- **Multi-backend Support**: Abstracts IPFS, Arweave, and other storage providers
- **Metadata Management**: Handles complex Lens publication metadata
- **Performance Optimization**: Intelligent caching and CDN integration
- **Cost Efficiency**: Smart storage tiering based on content importance

## Architecture

### Grove Storage Stack

```
┌─────────────────────────────────────────────────────────┐
│                    Grove Client API                      │
├─────────────────────────────────────────────────────────┤
│                  Metadata Processor                      │
│            (Lens Schema Validation & Transform)          │
├─────────────────────────────────────────────────────────┤
│                   Storage Router                         │
│              (Intelligent Backend Selection)             │
├──────────────┬──────────────┬──────────────┬───────────┤
│     IPFS     │   Arweave    │   Pinata     │    CDN    │
│   Gateway    │   Gateway    │     API      │   Cache   │
└──────────────┴──────────────┴──────────────┴───────────┘
```

## Implementation

### Grove Client Setup

```typescript
import { GroveClient } from '@lens-protocol/grove';

export const groveClient = new GroveClient({
  // Primary storage configuration
  storage: {
    ipfs: {
      gateway: process.env.IPFS_GATEWAY_URL,
      projectId: process.env.INFURA_PROJECT_ID,
      projectSecret: process.env.INFURA_PROJECT_SECRET,
    },
    arweave: {
      host: 'arweave.net',
      port: 443,
      protocol: 'https',
      wallet: process.env.ARWEAVE_WALLET,
    },
    pinata: {
      apiKey: process.env.PINATA_API_KEY,
      secretKey: process.env.PINATA_SECRET_KEY,
    },
  },
  
  // CDN configuration for performance
  cdn: {
    enabled: true,
    provider: 'cloudflare',
    baseUrl: process.env.CDN_BASE_URL,
  },
  
  // Lens-specific settings
  lens: {
    environment: 'production',
    validateMetadata: true,
    schemaVersion: '2.0.0',
  },
});
```

### Content Upload

```typescript
export async function uploadToGrove(
  content: LensContent
): Promise<GroveUploadResult> {
  try {
    // Validate Lens metadata schema
    const validatedContent = await groveClient.validateLensMetadata(content);
    
    // Process media files
    const processedMedia = await groveClient.processMedia(content.media, {
      optimize: true,
      generateThumbnails: true,
      maxSize: 50 * 1024 * 1024, // 50MB limit
    });
    
    // Upload to Grove
    const result = await groveClient.upload({
      metadata: validatedContent,
      media: processedMedia,
      options: {
        permanent: content.important,
        redundancy: content.important ? 3 : 1,
        encryption: content.private,
      },
    });
    
    return {
      uri: result.uri,
      txId: result.arweaveId,
      ipfsHash: result.ipfsHash,
      cdnUrl: result.cdnUrl,
    };
  } catch (error) {
    console.error('Grove upload failed:', error);
    throw new GroveUploadError('Failed to upload content', error);
  }
}
```

### Metadata Processing

<Callout type="info">
Grove automatically handles Lens metadata validation and transformation to ensure compatibility across the ecosystem.
</Callout>

```typescript
export class GroveMetadataProcessor {
  async processPublication(
    content: RawContent
  ): Promise<LensPublication> {
    // Extract and validate metadata
    const metadata = this.extractMetadata(content);
    
    // Transform to Lens schema
    const lensMetadata: LensPublication = {
      version: '2.0.0',
      metadata_id: this.generateMetadataId(),
      name: metadata.title || 'Untitled',
      description: metadata.description,
      content: content.body,
      external_url: metadata.externalUrl,
      image: metadata.coverImage,
      imageMimeType: metadata.coverImageMimeType,
      media: await this.processMediaItems(content.media),
      attributes: this.buildAttributes(metadata),
      locale: metadata.locale || 'en',
      tags: metadata.tags,
      contentWarning: metadata.contentWarning,
      hideFromFeed: metadata.hideFromFeed || false,
      appId: 'paper',
    };
    
    // Validate against Lens schema
    await this.validateSchema(lensMetadata);
    
    return lensMetadata;
  }
  
  private async processMediaItems(
    media: MediaItem[]
  ): Promise<LensMedia[]> {
    return Promise.all(
      media.map(async (item) => {
        // Upload to Grove storage
        const uploadResult = await groveClient.uploadMedia(item);
        
        return {
          item: uploadResult.uri,
          type: item.mimeType,
          altTag: item.altText,
          cover: item.thumbnail ? await this.uploadThumbnail(item.thumbnail) : undefined,
        };
      })
    );
  }
}
```

## Storage Strategy

### Intelligent Routing

Grove intelligently routes content to the most appropriate storage backend:

```typescript
export class GroveStorageRouter {
  async determineStorage(
    content: Content
  ): Promise<StorageBackend> {
    const analysis = await this.analyzeContent(content);
    
    // High-value content goes to Arweave
    if (analysis.permanenceScore > 0.8) {
      return {
        primary: 'arweave',
        backup: 'ipfs',
        cdn: true,
      };
    }
    
    // Media-heavy content uses IPFS with Pinata
    if (analysis.mediaSize > 10 * 1024 * 1024) {
      return {
        primary: 'ipfs',
        pinning: 'pinata',
        cdn: true,
      };
    }
    
    // Temporary content uses IPFS only
    if (analysis.ttl < 7 * 24 * 60 * 60) {
      return {
        primary: 'ipfs',
        pinning: false,
        cdn: false,
      };
    }
    
    // Default strategy
    return {
      primary: 'ipfs',
      pinning: 'pinata',
      backup: 'arweave',
      cdn: true,
    };
  }
}
```

### Content Retrieval

```typescript
export async function retrieveFromGrove(
  uri: string
): Promise<Content> {
  try {
    // Try CDN first for performance
    if (groveClient.cdn.isEnabled()) {
      const cached = await groveClient.cdn.get(uri);
      if (cached) return cached;
    }
    
    // Parse URI to determine storage type
    const storage = groveClient.parseUri(uri);
    
    // Retrieve from appropriate backend
    let content: Content;
    
    switch (storage.type) {
      case 'ipfs':
        content = await groveClient.ipfs.get(storage.hash);
        break;
      
      case 'arweave':
        content = await groveClient.arweave.get(storage.txId);
        break;
      
      case 'https':
        content = await fetch(uri).then(res => res.json());
        break;
      
      default:
        throw new Error(`Unsupported URI type: ${storage.type}`);
    }
    
    // Cache for future requests
    if (groveClient.cdn.isEnabled()) {
      await groveClient.cdn.put(uri, content);
    }
    
    return content;
  } catch (error) {
    // Fallback retrieval strategies
    return groveClient.fallbackRetrieval(uri);
  }
}
```

## Lens Integration

### Publication Creation

```typescript
export async function createLensPublication(
  content: PostContent
): Promise<string> {
  // Process through Grove
  const groveResult = await groveClient.createPublication({
    content: content.body,
    media: content.media,
    metadata: {
      title: content.title,
      tags: content.tags,
      attributes: content.attributes,
    },
  });
  
  // Create Lens post with Grove URI
  const tx = await lensHub.post({
    profileId: currentProfile.id,
    contentURI: groveResult.uri,
    collectModule: freeCollectModule.address,
    referenceModule: followerOnlyReferenceModule.address,
  });
  
  await tx.wait();
  
  // Index in Grove for fast retrieval
  await groveClient.index({
    publicationId: tx.publicationId,
    uri: groveResult.uri,
    profile: currentProfile.handle,
  });
  
  return tx.publicationId;
}
```

### Cross-Platform Sync

```typescript
export class GroveSyncManager {
  async syncWithLens(
    publicationId: string
  ): Promise<SyncResult> {
    // Fetch from Lens
    const publication = await lensClient.publication.fetch({
      publicationId,
    });
    
    // Import to Grove
    const groveData = await groveClient.import({
      uri: publication.metadata.uri,
      options: {
        mirror: true,
        optimize: true,
        backup: true,
      },
    });
    
    // Update local index
    await this.updateIndex({
      publicationId,
      groveUri: groveData.uri,
      originalUri: publication.metadata.uri,
      syncedAt: Date.now(),
    });
    
    return {
      success: true,
      groveUri: groveData.uri,
      optimizations: groveData.optimizations,
    };
  }
}
```

## Performance Optimization

### Caching Strategy

```typescript
export class GroveCacheManager {
  private memoryCache = new LRU<string, Content>(100);
  private diskCache: DiskCache;
  
  async get(uri: string): Promise<Content | null> {
    // Check memory cache
    const memCached = this.memoryCache.get(uri);
    if (memCached) return memCached;
    
    // Check disk cache
    const diskCached = await this.diskCache.get(uri);
    if (diskCached) {
      this.memoryCache.set(uri, diskCached);
      return diskCached;
    }
    
    // Fetch from Grove
    const content = await groveClient.get(uri);
    if (content) {
      await this.cache(uri, content);
    }
    
    return content;
  }
  
  private async cache(
    uri: string,
    content: Content
  ): Promise<void> {
    // Memory cache for hot content
    this.memoryCache.set(uri, content);
    
    // Disk cache for warm content
    if (this.shouldDiskCache(content)) {
      await this.diskCache.set(uri, content, {
        ttl: this.calculateTTL(content),
      });
    }
  }
}
```

### Batch Operations

```typescript
export async function batchUploadToGrove(
  items: Content[]
): Promise<GroveUploadResult[]> {
  // Group by content type for optimization
  const grouped = groupBy(items, item => 
    item.media.length > 0 ? 'media' : 'text'
  );
  
  // Process in parallel batches
  const results = await Promise.all([
    groveClient.batchUploadText(grouped.text || []),
    groveClient.batchUploadMedia(grouped.media || []),
  ]);
  
  return results.flat();
}
```

## Cost Management

### Storage Tiering

```typescript
export class GroveStorageTier {
  async optimizeStorage(
    content: StoredContent
  ): Promise<OptimizationResult> {
    const usage = await this.analyzeUsage(content);
    
    // Move cold data to cheaper storage
    if (usage.accessCount < 10 && usage.ageInDays > 30) {
      await this.moveToArchive(content);
      return { moved: 'archive', saved: this.calculateSavings(content) };
    }
    
    // Keep hot data in fast storage
    if (usage.accessCount > 100 && usage.ageInDays < 7) {
      await this.moveToHotStorage(content);
      return { moved: 'hot', cost: this.calculateCost(content) };
    }
    
    return { moved: null, optimized: false };
  }
}
```

## Monitoring & Analytics

### Usage Metrics

```typescript
export async function getGroveMetrics(): Promise<GroveMetrics> {
  const metrics = await groveClient.analytics.getMetrics({
    period: 'last_30_days',
  });
  
  return {
    totalUploads: metrics.uploads.total,
    totalDownloads: metrics.downloads.total,
    storageUsed: metrics.storage.used,
    storageCost: metrics.storage.cost,
    bandwidthUsed: metrics.bandwidth.used,
    cacheHitRate: metrics.cache.hitRate,
    avgUploadTime: metrics.performance.avgUploadTime,
    avgDownloadTime: metrics.performance.avgDownloadTime,
  };
}
```

### Health Monitoring

```typescript
export class GroveHealthMonitor {
  async checkHealth(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkIPFS(),
      this.checkArweave(),
      this.checkPinata(),
      this.checkCDN(),
    ]);
    
    return {
      ipfs: checks[0].status === 'fulfilled',
      arweave: checks[1].status === 'fulfilled',
      pinata: checks[2].status === 'fulfilled',
      cdn: checks[3].status === 'fulfilled',
      overall: checks.every(c => c.status === 'fulfilled'),
    };
  }
}
```

## Best Practices

### Content Optimization
- Pre-process media before upload
- Use appropriate compression
- Generate multiple resolutions
- Implement lazy loading

### Reliability
- Implement retry logic
- Use multiple storage backends
- Regular health checks
- Fallback strategies

### Performance
- Leverage CDN caching
- Batch operations when possible
- Use memory caching for hot content
- Optimize metadata structure

### Cost Efficiency
- Implement storage tiering
- Monitor usage patterns
- Archive cold data
- Use appropriate redundancy levels

## Grove Configuration

### Environment Variables

```bash
# Grove Storage Configuration
GROVE_API_KEY=your_grove_api_key
GROVE_SECRET_KEY=your_grove_secret_key

# IPFS Configuration
IPFS_GATEWAY_URL=https://ipfs.infura.io:5001
INFURA_PROJECT_ID=your_infura_project_id
INFURA_PROJECT_SECRET=your_infura_secret

# Arweave Configuration
ARWEAVE_WALLET=your_arweave_wallet_json

# Pinata Configuration
PINATA_API_KEY=your_pinata_api_key
PINATA_SECRET_KEY=your_pinata_secret_key

# CDN Configuration
CDN_BASE_URL=https://cdn.paper.xyz
CDN_API_KEY=your_cdn_api_key
```

## Migration Guide

### Migrating from Direct IPFS

```typescript
export async function migrateToGrove(
  ipfsHash: string
): Promise<string> {
  // Fetch from IPFS
  const content = await ipfsClient.get(ipfsHash);
  
  // Upload to Grove with optimizations
  const groveResult = await groveClient.migrate({
    source: 'ipfs',
    content,
    options: {
      optimize: true,
      backup: true,
      preserveOriginal: true,
    },
  });
  
  return groveResult.uri;
}
```