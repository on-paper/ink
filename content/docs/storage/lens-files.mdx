---
title: Lens Files
description: Structured data management with Lens Protocol
---

import { Callout } from 'fumadocs-ui/components/callout';

# Lens Files Integration

Lens Files provides structured data management for Paper, enabling cross-platform compatibility and rich metadata support.

## Overview

Lens Files offers:

- **Structured Metadata**: Standardized content format
- **Cross-platform Support**: Works across Lens ecosystem
- **Rich Media**: Native support for various content types
- **Versioning**: Track content evolution
- **Composability**: Build on existing content

## File Structure

### Lens Publication Format

```typescript
interface LensPublication {
  version: '2.0.0';
  metadata_id: string;
  description: string;
  content: string;
  external_url?: string;
  image?: string;
  imageMimeType?: string;
  name: string;
  attributes: Attribute[];
  media: Media[];
  appId: string;
}

interface Attribute {
  displayType?: 'string' | 'number' | 'date';
  traitType: string;
  value: string | number;
}

interface Media {
  item: string;
  type: string;
  altTag?: string;
  cover?: string;
}
```

## Implementation

### Creating Lens Files

```typescript
export class LensFileManager {
  async createPublication(
    content: PostContent
  ): Promise<LensPublication> {
    // Generate metadata ID
    const metadataId = generateMetadataId();
    
    // Process media files
    const media = await this.processMedia(content.media);
    
    // Build publication
    const publication: LensPublication = {
      version: '2.0.0',
      metadata_id: metadataId,
      name: content.title || 'Paper Post',
      description: this.extractDescription(content.body),
      content: content.body,
      external_url: `https://paper.xyz/p/${content.id}`,
      image: media[0]?.item,
      imageMimeType: media[0]?.type,
      media,
      attributes: this.buildAttributes(content),
      appId: 'paper',
    };
    
    // Validate schema
    this.validatePublication(publication);
    
    return publication;
  }
  
  private buildAttributes(content: PostContent): Attribute[] {
    return [
      {
        traitType: 'type',
        value: content.type,
      },
      {
        traitType: 'tags',
        value: content.tags.join(','),
      },
      {
        traitType: 'created',
        displayType: 'date',
        value: content.createdAt,
      },
      {
        traitType: 'author',
        value: content.author,
      },
    ];
  }
}
```

### Media Processing

```typescript
export async function processMedia(
  files: File[]
): Promise<Media[]> {
  const processed: Media[] = [];
  
  for (const file of files) {
    // Upload to IPFS
    const cid = await uploadToIPFS(file);
    
    // Determine media type
    const mediaType = getMediaType(file.type);
    
    // Generate cover for videos
    let cover: string | undefined;
    if (mediaType === 'video') {
      const thumbnail = await generateVideoThumbnail(file);
      cover = await uploadToIPFS(thumbnail);
    }
    
    processed.push({
      item: `ipfs://${cid}`,
      type: file.type,
      altTag: file.name,
      cover: cover ? `ipfs://${cover}` : undefined,
    });
  }
  
  return processed;
}
```

### Content Validation

<Callout type="warning">
Always validate Lens Files against the schema to ensure compatibility.
</Callout>

```typescript
import { validateLensPublication } from '@lens-protocol/metadata';

export function validatePublication(
  publication: LensPublication
): void {
  const result = validateLensPublication(publication);
  
  if (!result.valid) {
    throw new Error(
      `Invalid publication: ${result.errors.join(', ')}`
    );
  }
}
```

## Storage Integration

### Hybrid Storage Approach

```typescript
export class LensStorageAdapter {
  async store(publication: LensPublication): Promise<StorageResult> {
    // Store metadata on Arweave
    const metadataId = await this.storeMetadata(publication);
    
    // Store media on IPFS
    const mediaUrls = await this.storeMedia(publication.media);
    
    // Create on-chain pointer
    const txHash = await this.createOnChainReference({
      metadataId,
      publicationId: publication.metadata_id,
      author: currentUser,
    });
    
    return {
      metadataId,
      mediaUrls,
      txHash,
    };
  }
  
  private async storeMetadata(
    publication: LensPublication
  ): Promise<string> {
    // Upload to Arweave for permanence
    const arweaveId = await uploadToArweave(
      JSON.stringify(publication),
      [
        { name: 'Content-Type', value: 'application/json' },
        { name: 'App-Name', value: 'Paper' },
        { name: 'Publication-Id', value: publication.metadata_id },
      ]
    );
    
    return arweaveId;
  }
}
```

### Content Retrieval

```typescript
export async function getLensPublication(
  metadataId: string
): Promise<LensPublication> {
  try {
    // Try Arweave first
    const data = await getFromArweave(metadataId);
    return JSON.parse(data);
  } catch {
    // Fallback to IPFS
    const cid = await resolveMetadataId(metadataId);
    const data = await getFromIPFS(cid);
    return JSON.parse(data);
  }
}
```

## Rich Content Types

### Article Publications

```typescript
export function createArticle(
  article: Article
): LensPublication {
  return {
    version: '2.0.0',
    metadata_id: generateMetadataId(),
    name: article.title,
    description: article.excerpt,
    content: article.content,
    external_url: article.url,
    image: article.coverImage,
    imageMimeType: 'image/jpeg',
    media: [],
    attributes: [
      {
        traitType: 'type',
        value: 'article',
      },
      {
        traitType: 'readTime',
        displayType: 'number',
        value: calculateReadTime(article.content),
      },
      {
        traitType: 'category',
        value: article.category,
      },
    ],
    appId: 'paper',
  };
}
```

### Video Publications

```typescript
export function createVideoPublication(
  video: VideoContent
): LensPublication {
  return {
    version: '2.0.0',
    metadata_id: generateMetadataId(),
    name: video.title,
    description: video.description,
    content: video.description,
    external_url: video.url,
    image: video.thumbnail,
    imageMimeType: 'image/jpeg',
    media: [
      {
        item: video.videoUrl,
        type: 'video/mp4',
        cover: video.thumbnail,
      },
    ],
    attributes: [
      {
        traitType: 'type',
        value: 'video',
      },
      {
        traitType: 'duration',
        displayType: 'number',
        value: video.duration,
      },
      {
        traitType: 'views',
        displayType: 'number',
        value: 0,
      },
    ],
    appId: 'paper',
  };
}
```

### Gallery Publications

```typescript
export function createGallery(
  images: ImageContent[]
): LensPublication {
  const media = images.map(img => ({
    item: img.url,
    type: img.mimeType,
    altTag: img.description,
  }));
  
  return {
    version: '2.0.0',
    metadata_id: generateMetadataId(),
    name: 'Photo Gallery',
    description: `Gallery with ${images.length} photos`,
    content: images.map(img => img.description).join('\n'),
    image: images[0]?.url,
    imageMimeType: images[0]?.mimeType,
    media,
    attributes: [
      {
        traitType: 'type',
        value: 'gallery',
      },
      {
        traitType: 'imageCount',
        displayType: 'number',
        value: images.length,
      },
    ],
    appId: 'paper',
  };
}
```

## Metadata Management

### Versioning System

```typescript
export class MetadataVersioning {
  async createVersion(
    publication: LensPublication,
    changes: Partial<LensPublication>
  ): Promise<LensPublication> {
    // Create new version
    const newVersion = {
      ...publication,
      ...changes,
      metadata_id: generateMetadataId(),
      attributes: [
        ...publication.attributes,
        {
          traitType: 'previousVersion',
          value: publication.metadata_id,
        },
        {
          traitType: 'versionNumber',
          displayType: 'number',
          value: this.getVersionNumber(publication) + 1,
        },
      ],
    };
    
    // Store new version
    await this.store(newVersion);
    
    // Link versions
    await this.linkVersions(
      publication.metadata_id,
      newVersion.metadata_id
    );
    
    return newVersion;
  }
  
  private getVersionNumber(
    publication: LensPublication
  ): number {
    const version = publication.attributes.find(
      attr => attr.traitType === 'versionNumber'
    );
    
    return version ? Number(version.value) : 1;
  }
}
```

### Metadata Indexing

```typescript
export class MetadataIndexer {
  private index = new Map<string, LensPublication>();
  
  async indexPublication(
    publication: LensPublication
  ): Promise<void> {
    // Store in local index
    this.index.set(publication.metadata_id, publication);
    
    // Index attributes for search
    await this.indexAttributes(publication);
    
    // Update search index
    await this.updateSearchIndex(publication);
  }
  
  private async indexAttributes(
    publication: LensPublication
  ): Promise<void> {
    for (const attr of publication.attributes) {
      await db.attributes.create({
        publicationId: publication.metadata_id,
        traitType: attr.traitType,
        value: attr.value,
        displayType: attr.displayType,
      });
    }
  }
}
```

## Cross-Platform Compatibility

### Lens Protocol Integration

```typescript
export async function publishToLens(
  publication: LensPublication
): Promise<string> {
  // Upload metadata
  const metadataUri = await uploadMetadata(publication);
  
  // Create Lens post
  const tx = await lensHub.post({
    profileId: currentProfile.id,
    contentURI: metadataUri,
    collectModule: freeCollectModule.address,
    collectModuleInitData: defaultModuleData,
    referenceModule: followerOnlyReferenceModule.address,
    referenceModuleInitData: defaultModuleData,
  });
  
  const receipt = await tx.wait();
  
  return extractPublicationId(receipt);
}
```

### Import from Lens

```typescript
export async function importFromLens(
  publicationId: string
): Promise<PostContent> {
  // Fetch publication
  const publication = await lensClient.publication.fetch({
    publicationId,
  });
  
  // Parse metadata
  const metadata = await fetchMetadata(
    publication.metadata.uri
  );
  
  // Convert to Paper format
  return {
    id: generatePostId(),
    title: metadata.name,
    body: metadata.content,
    media: metadata.media.map(m => ({
      url: m.item,
      type: m.type,
    })),
    tags: extractTags(metadata.attributes),
    author: publication.profile.handle,
    createdAt: publication.createdAt,
  };
}
```

## Search & Discovery

### Attribute-Based Search

```typescript
export async function searchByAttributes(
  filters: AttributeFilter[]
): Promise<LensPublication[]> {
  const query = buildAttributeQuery(filters);
  
  const results = await db.publications.find({
    where: {
      attributes: {
        some: query,
      },
    },
    include: {
      attributes: true,
      media: true,
    },
  });
  
  return results.map(r => reconstructPublication(r));
}

function buildAttributeQuery(
  filters: AttributeFilter[]
): any {
  return {
    AND: filters.map(filter => ({
      traitType: filter.trait,
      value: filter.value,
    })),
  };
}
```

### Content Discovery

```typescript
export class ContentDiscovery {
  async getSimilarContent(
    publication: LensPublication
  ): Promise<LensPublication[]> {
    // Extract features
    const features = this.extractFeatures(publication);
    
    // Find similar publications
    const similar = await this.findSimilar(features, {
      limit: 10,
      exclude: [publication.metadata_id],
    });
    
    return similar;
  }
  
  private extractFeatures(
    publication: LensPublication
  ): Features {
    return {
      type: this.getType(publication),
      tags: this.getTags(publication),
      category: this.getCategory(publication),
      mediaCount: publication.media.length,
    };
  }
}
```

## Performance Optimization

### Lazy Loading

```typescript
export function useLensPublication(metadataId: string) {
  const [publication, setPublication] = useState<LensPublication | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    let cancelled = false;
    
    async function load() {
      try {
        // Check cache first
        const cached = await cache.get(metadataId);
        
        if (cached && !cancelled) {
          setPublication(cached);
          setLoading(false);
          return;
        }
        
        // Fetch from storage
        const pub = await getLensPublication(metadataId);
        
        if (!cancelled) {
          setPublication(pub);
          cache.set(metadataId, pub);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }
    
    load();
    
    return () => {
      cancelled = true;
    };
  }, [metadataId]);
  
  return { publication, loading };
}
```

### Batch Processing

```typescript
export async function batchProcessPublications(
  publications: LensPublication[]
): Promise<void> {
  // Group by operation type
  const batches = groupBy(publications, pub => 
    pub.attributes.find(a => a.traitType === 'type')?.value
  );
  
  // Process each batch in parallel
  await Promise.all(
    Object.entries(batches).map(([type, pubs]) => 
      this.processBatch(type, pubs)
    )
  );
}
```

## Best Practices

### Schema Compliance
- Always validate against Lens schema
- Use proper version numbers
- Include required fields
- Follow naming conventions

### Performance
- Cache frequently accessed metadata
- Lazy load media content
- Batch operations when possible
- Use CDN for media delivery

### Interoperability
- Maintain Lens compatibility
- Support standard media types
- Use common attribute names
- Document custom extensions