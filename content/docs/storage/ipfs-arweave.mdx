---
title: IPFS & Arweave Storage
description: Decentralized storage solutions for permanent content
---

import { Callout } from 'fumadocs-ui/components/callout';

# IPFS & Arweave Storage

Paper uses a hybrid storage approach combining IPFS for distributed content delivery and Arweave for permanent archival.

## Storage Strategy

### Content Types & Storage

| Content Type | Primary Storage | Backup | Retention |
|-------------|----------------|---------|-----------|
| Posts | IPFS | Arweave | Permanent |
| Comments | IPFS | - | 1 year |
| Media | IPFS | Arweave | Permanent |
| Profiles | IPFS | On-chain | Permanent |
| Metadata | On-chain | IPFS | Permanent |

## IPFS Integration

### Overview

IPFS (InterPlanetary File System) provides:

- **Content Addressing**: Unique CIDs for each piece of content
- **P2P Distribution**: Decentralized content delivery
- **Deduplication**: Automatic removal of duplicate content
- **Versioning**: Track content changes over time

### Implementation

#### IPFS Client Setup

```typescript
import { create } from 'ipfs-http-client';

export const ipfsClient = create({
  host: process.env.IPFS_HOST || 'ipfs.infura.io',
  port: 5001,
  protocol: 'https',
  headers: {
    authorization: `Basic ${Buffer.from(
      `${INFURA_PROJECT_ID}:${INFURA_SECRET}`
    ).toString('base64')}`,
  },
});
```

#### Content Upload

```typescript
export async function uploadToIPFS(
  content: string | Buffer
): Promise<string> {
  try {
    // Add content to IPFS
    const result = await ipfsClient.add(content, {
      pin: true, // Pin to ensure persistence
      wrapWithDirectory: false,
    });
    
    // Return CID
    return result.cid.toString();
  } catch (error) {
    console.error('IPFS upload failed:', error);
    throw new Error('Failed to upload content');
  }
}
```

#### Content Retrieval

```typescript
export async function getFromIPFS(cid: string): Promise<string> {
  try {
    const chunks = [];
    
    for await (const chunk of ipfsClient.cat(cid)) {
      chunks.push(chunk);
    }
    
    return Buffer.concat(chunks).toString('utf-8');
  } catch (error) {
    // Fallback to public gateway
    return fetchFromGateway(cid);
  }
}

async function fetchFromGateway(cid: string): Promise<string> {
  const gateways = [
    'https://ipfs.io',
    'https://gateway.pinata.cloud',
    'https://cloudflare-ipfs.com',
  ];
  
  for (const gateway of gateways) {
    try {
      const response = await fetch(`${gateway}/ipfs/${cid}`);
      if (response.ok) {
        return response.text();
      }
    } catch {
      continue;
    }
  }
  
  throw new Error('Content not available');
}
```

### Pinning Strategy

<Callout type="info">
Pinning ensures content remains available on IPFS by preventing garbage collection.
</Callout>

```typescript
export class PinningService {
  private pinata: PinataSDK;
  
  constructor() {
    this.pinata = new PinataSDK(
      PINATA_API_KEY,
      PINATA_SECRET_KEY
    );
  }
  
  async pinContent(cid: string, metadata?: any): Promise<void> {
    await this.pinata.pinByHash(cid, {
      pinataMetadata: {
        name: metadata?.name || 'Paper Content',
        keyvalues: {
          author: metadata?.author,
          timestamp: Date.now(),
          type: metadata?.type || 'post',
        },
      },
    });
  }
  
  async unpinContent(cid: string): Promise<void> {
    await this.pinata.unpin(cid);
  }
  
  async getPinList(): Promise<Pin[]> {
    const result = await this.pinata.pinList({
      status: 'pinned',
      pageLimit: 100,
    });
    
    return result.rows;
  }
}
```

## Arweave Integration

### Overview

Arweave provides:

- **Permanent Storage**: Pay once, store forever
- **Proof of Access**: Cryptographic guarantees
- **SmartWeave**: Smart contract capabilities
- **High Availability**: Replicated across network

### Implementation

#### Arweave Client

```typescript
import Arweave from 'arweave';

export const arweave = Arweave.init({
  host: 'arweave.net',
  port: 443,
  protocol: 'https',
});

// Load wallet for transactions
export async function loadWallet(): Promise<JWKInterface> {
  const wallet = JSON.parse(
    process.env.ARWEAVE_WALLET || '{}'
  );
  return wallet;
}
```

#### Permanent Upload

```typescript
export async function uploadToArweave(
  data: string | Buffer,
  tags: Tag[] = []
): Promise<string> {
  const wallet = await loadWallet();
  
  // Create transaction
  const transaction = await arweave.createTransaction({
    data,
  }, wallet);
  
  // Add tags for indexing
  transaction.addTag('App-Name', 'Paper');
  transaction.addTag('Content-Type', 'application/json');
  transaction.addTag('Version', '1.0');
  
  // Add custom tags
  tags.forEach(tag => {
    transaction.addTag(tag.name, tag.value);
  });
  
  // Sign and submit
  await arweave.transactions.sign(transaction, wallet);
  
  const response = await arweave.transactions.post(transaction);
  
  if (response.status === 200) {
    return transaction.id;
  }
  
  throw new Error('Arweave upload failed');
}
```

#### Content Retrieval

```typescript
export async function getFromArweave(txId: string): Promise<string> {
  try {
    // Direct retrieval
    const data = await arweave.transactions.getData(txId, {
      decode: true,
      string: true,
    });
    
    return data as string;
  } catch (error) {
    // Fallback to gateway
    const response = await fetch(
      `https://arweave.net/${txId}`
    );
    
    if (response.ok) {
      return response.text();
    }
    
    throw new Error('Content not found');
  }
}
```

### GraphQL Queries

```typescript
export async function queryArweave(
  tags: { name: string; values: string[] }[]
): Promise<Transaction[]> {
  const query = `
    query {
      transactions(
        tags: ${JSON.stringify(tags)}
        first: 100
      ) {
        edges {
          node {
            id
            tags {
              name
              value
            }
            block {
              timestamp
            }
          }
        }
      }
    }
  `;
  
  const response = await arweave.api.post('graphql', { query });
  
  return response.data.data.transactions.edges.map(
    edge => edge.node
  );
}
```

## Hybrid Storage Flow

### Upload Pipeline

```typescript
export class StorageManager {
  async store(content: Content): Promise<StorageResult> {
    // 1. Upload to IPFS for immediate availability
    const ipfsCid = await uploadToIPFS(content.data);
    
    // 2. Pin on multiple services
    await Promise.all([
      pinningService.pinContent(ipfsCid, content.metadata),
      secondaryPinning.pin(ipfsCid),
    ]);
    
    // 3. Archive to Arweave if important
    let arweaveId: string | null = null;
    
    if (content.permanent) {
      arweaveId = await uploadToArweave(
        content.data,
        [
          { name: 'IPFS-CID', value: ipfsCid },
          { name: 'Author', value: content.author },
          { name: 'Type', value: content.type },
        ]
      );
    }
    
    // 4. Store references on-chain
    await storeOnChain({
      ipfsCid,
      arweaveId,
      author: content.author,
      timestamp: Date.now(),
    });
    
    return {
      ipfsCid,
      arweaveId,
      gateway: `https://ipfs.io/ipfs/${ipfsCid}`,
    };
  }
}
```

### Retrieval Strategy

```typescript
export async function retrieveContent(
  reference: ContentReference
): Promise<string> {
  // Try IPFS first (faster)
  if (reference.ipfsCid) {
    try {
      return await getFromIPFS(reference.ipfsCid);
    } catch (error) {
      console.warn('IPFS retrieval failed:', error);
    }
  }
  
  // Fall back to Arweave
  if (reference.arweaveId) {
    try {
      return await getFromArweave(reference.arweaveId);
    } catch (error) {
      console.warn('Arweave retrieval failed:', error);
    }
  }
  
  // Last resort: check cached version
  const cached = await getCachedContent(reference);
  if (cached) {
    return cached;
  }
  
  throw new Error('Content unavailable');
}
```

## Media Handling

### Image Optimization

```typescript
export async function uploadImage(
  file: File
): Promise<MediaUploadResult> {
  // Optimize image
  const optimized = await optimizeImage(file, {
    maxWidth: 1920,
    maxHeight: 1080,
    quality: 0.85,
  });
  
  // Generate thumbnails
  const thumbnail = await generateThumbnail(optimized, {
    width: 400,
    height: 400,
  });
  
  // Upload both versions
  const [originalCid, thumbnailCid] = await Promise.all([
    uploadToIPFS(optimized),
    uploadToIPFS(thumbnail),
  ]);
  
  return {
    original: originalCid,
    thumbnail: thumbnailCid,
    metadata: {
      size: optimized.size,
      type: file.type,
      dimensions: await getImageDimensions(optimized),
    },
  };
}
```

### Video Processing

```typescript
export async function uploadVideo(
  file: File
): Promise<VideoUploadResult> {
  // Check size limits
  if (file.size > MAX_VIDEO_SIZE) {
    throw new Error('Video too large');
  }
  
  // Generate poster frame
  const poster = await extractPosterFrame(file);
  
  // Upload to IPFS
  const [videoCid, posterCid] = await Promise.all([
    uploadToIPFS(file),
    uploadToIPFS(poster),
  ]);
  
  // Queue for Arweave backup
  await queueForArchival(videoCid);
  
  return {
    video: videoCid,
    poster: posterCid,
    duration: await getVideoDuration(file),
  };
}
```

## Cost Optimization

### Storage Tiers

```typescript
enum StorageTier {
  HOT = 'hot',       // IPFS only, frequently accessed
  WARM = 'warm',     // IPFS + pinning service
  COLD = 'cold',     // Arweave only, rarely accessed
  ARCHIVE = 'archive' // Arweave with minimal indexing
}

export function determineStorageTier(
  content: Content
): StorageTier {
  // Recent popular content
  if (content.views > 1000 && content.age < 7) {
    return StorageTier.HOT;
  }
  
  // Standard content
  if (content.permanent) {
    return StorageTier.WARM;
  }
  
  // Old content with value
  if (content.age > 365 && content.likes > 10) {
    return StorageTier.COLD;
  }
  
  // Everything else
  return StorageTier.ARCHIVE;
}
```

### Garbage Collection

```typescript
export class StorageGarbageCollector {
  async cleanup(): Promise<void> {
    // Get all pinned content
    const pins = await pinningService.getPinList();
    
    for (const pin of pins) {
      const metadata = pin.metadata;
      
      // Check if content should be unpinned
      if (this.shouldUnpin(metadata)) {
        await pinningService.unpinContent(pin.ipfs_pin_hash);
      }
      
      // Check if content should be archived
      if (this.shouldArchive(metadata)) {
        await this.archiveContent(pin.ipfs_pin_hash);
      }
    }
  }
  
  private shouldUnpin(metadata: any): boolean {
    const age = Date.now() - metadata.timestamp;
    const views = metadata.views || 0;
    
    // Unpin if old and rarely accessed
    return age > 30 * 24 * 60 * 60 * 1000 && views < 10;
  }
}
```

## Monitoring

### Health Checks

```typescript
export class StorageMonitor {
  async checkHealth(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkIPFS(),
      this.checkArweave(),
      this.checkPinning(),
    ]);
    
    return {
      ipfs: checks[0].status === 'fulfilled',
      arweave: checks[1].status === 'fulfilled',
      pinning: checks[2].status === 'fulfilled',
      timestamp: Date.now(),
    };
  }
  
  private async checkIPFS(): Promise<void> {
    const testCid = 'QmTest...';
    await ipfsClient.pin.ls(testCid);
  }
  
  private async checkArweave(): Promise<void> {
    const network = await arweave.network.getInfo();
    if (network.height < 1) {
      throw new Error('Arweave network unreachable');
    }
  }
}
```

## Best Practices

### Reliability
- Always have multiple storage backends
- Implement retry logic with exponential backoff
- Monitor storage health continuously
- Cache frequently accessed content

### Performance
- Use IPFS for hot content
- Batch uploads when possible
- Implement progressive loading for media
- Use CDN for gateway acceleration

### Cost Management
- Archive old content to Arweave
- Unpin rarely accessed IPFS content
- Use storage tiers appropriately
- Monitor storage costs regularly