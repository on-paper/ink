---
title: Gasless Transactions
description: Seamless UX with sponsored transactions for approved users
---

import { Callout } from 'fumadocs-ui/components/callout';

# Gasless Transactions

Paper implements gasless transactions to remove friction from user interactions, allowing approved users to perform actions without holding ETH.

## Overview

Gasless transactions enable:

- **Zero-cost interactions**: Users don't need ETH
- **Improved onboarding**: No wallet funding required
- **Higher engagement**: Remove transaction barriers
- **Selective sponsorship**: Control who gets gasless access

## Architecture

### System Components

```
┌──────────────────┐     ┌──────────────────┐
│      User        │────▶│   Paper Frontend │
└──────────────────┘     └──────────────────┘
                                  │
                                  ▼
                         ┌──────────────────┐
                         │  Gasless Router  │
                         └──────────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    ▼                           ▼
          ┌──────────────────┐       ┌──────────────────┐
          │ Approval Checker │       │   Fee Estimator   │
          └──────────────────┘       └──────────────────┘
                    │                           │
                    └─────────────┬─────────────┘
                                  ▼
                         ┌──────────────────┐
                         │     Relayer      │
                         └──────────────────┘
                                  │
                                  ▼
                         ┌──────────────────┐
                         │    Blockchain    │
                         └──────────────────┘
```

## Implementation

### Gasless Submitter

```typescript
export class GaslessSubmitter {
  private relayerUrl: string;
  private signer: Signer;
  
  constructor(config: GaslessConfig) {
    this.relayerUrl = config.relayerUrl;
    this.signer = new Wallet(config.relayerPrivateKey);
  }
  
  async submit(
    transaction: Transaction
  ): Promise<TransactionReceipt> {
    // Check if user is approved
    const approved = await this.isApproved(transaction.from);
    
    if (!approved) {
      throw new Error('User not approved for gasless transactions');
    }
    
    // Validate transaction
    await this.validateTransaction(transaction);
    
    // Sign meta-transaction
    const metaTx = await this.createMetaTransaction(transaction);
    const signature = await this.signMetaTransaction(metaTx);
    
    // Submit to relayer
    const response = await fetch(`${this.relayerUrl}/submit`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        transaction: metaTx,
        signature,
      }),
    });
    
    if (!response.ok) {
      throw new Error('Relayer submission failed');
    }
    
    const { txHash } = await response.json();
    
    // Wait for confirmation
    return this.waitForTransaction(txHash);
  }
  
  async isApproved(address: string): Promise<boolean> {
    // Check multiple criteria
    const checks = await Promise.all([
      this.hasENSName(address),
      this.meetsActivityThreshold(address),
      this.hasStake(address),
      this.isWhitelisted(address),
    ]);
    
    // User needs at least one approval criteria
    return checks.some(Boolean);
  }
}
```

### Meta-Transaction Format

<Callout type="info">
Meta-transactions allow users to sign transactions without paying gas, while a relayer submits them on-chain.
</Callout>

```typescript
interface MetaTransaction {
  from: string;
  to: string;
  value: BigNumber;
  data: string;
  nonce: number;
  deadline: number;
  chainId: number;
}

export async function createMetaTransaction(
  tx: Transaction
): Promise<MetaTransaction> {
  const nonce = await getNonce(tx.from);
  
  return {
    from: tx.from,
    to: tx.to!,
    value: tx.value || BigNumber.from(0),
    data: tx.data || '0x',
    nonce,
    deadline: Math.floor(Date.now() / 1000) + 3600, // 1 hour
    chainId: await getChainId(),
  };
}

export async function signMetaTransaction(
  metaTx: MetaTransaction,
  signer: Signer
): Promise<string> {
  const domain = {
    name: 'Paper Gasless',
    version: '1',
    chainId: metaTx.chainId,
    verifyingContract: FORWARDER_ADDRESS,
  };
  
  const types = {
    MetaTransaction: [
      { name: 'from', type: 'address' },
      { name: 'to', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'data', type: 'bytes' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
    ],
  };
  
  return signer._signTypedData(domain, types, metaTx);
}
```

## Approval System

### Approval Criteria

Users qualify for gasless transactions through:

```typescript
export class ApprovalSystem {
  async checkEligibility(address: string): Promise<EligibilityResult> {
    const criteria = await this.evaluateCriteria(address);
    
    return {
      approved: this.meetsRequirements(criteria),
      criteria,
      score: this.calculateScore(criteria),
    };
  }
  
  private async evaluateCriteria(
    address: string
  ): Promise<Criteria> {
    const [
      ensName,
      accountAge,
      followerCount,
      postCount,
      stake,
    ] = await Promise.all([
      this.getENSName(address),
      this.getAccountAge(address),
      this.getFollowerCount(address),
      this.getPostCount(address),
      this.getStakeAmount(address),
    ]);
    
    return {
      hasENS: !!ensName,
      accountAgeDays: accountAge,
      followers: followerCount,
      posts: postCount,
      stakeAmount: stake,
    };
  }
  
  private meetsRequirements(criteria: Criteria): boolean {
    // Automatic approval for ENS holders
    if (criteria.hasENS) return true;
    
    // Approval for active users
    if (criteria.followers >= 100 && criteria.posts >= 10) {
      return true;
    }
    
    // Approval for stakers
    if (criteria.stakeAmount.gte(MIN_STAKE_AMOUNT)) {
      return true;
    }
    
    // Approval for old accounts
    if (criteria.accountAgeDays >= 365) {
      return true;
    }
    
    return false;
  }
}
```

### Dynamic Approval

```typescript
export async function requestGaslessApproval(
  address: string
): Promise<ApprovalStatus> {
  // Check current status
  const currentStatus = await getApprovalStatus(address);
  
  if (currentStatus.approved) {
    return currentStatus;
  }
  
  // Evaluate eligibility
  const eligibility = await approvalSystem.checkEligibility(address);
  
  if (!eligibility.approved) {
    return {
      approved: false,
      reason: 'Does not meet eligibility criteria',
      suggestions: generateSuggestions(eligibility.criteria),
    };
  }
  
  // Grant approval
  await grantApproval(address, eligibility);
  
  return {
    approved: true,
    expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days
  };
}
```

## Relayer Infrastructure

### Relayer Service

```typescript
export class RelayerService {
  private wallet: Wallet;
  private provider: Provider;
  private queue: MetaTransaction[] = [];
  
  async processTransaction(
    metaTx: MetaTransaction,
    signature: string
  ): Promise<string> {
    // Verify signature
    const isValid = await this.verifySignature(metaTx, signature);
    
    if (!isValid) {
      throw new Error('Invalid signature');
    }
    
    // Check rate limits
    const canProcess = await this.checkRateLimit(metaTx.from);
    
    if (!canProcess) {
      throw new Error('Rate limit exceeded');
    }
    
    // Estimate gas
    const gasEstimate = await this.estimateGas(metaTx);
    
    // Check if profitable
    if (!this.isProfitable(gasEstimate)) {
      this.queue.push(metaTx);
      return this.batchProcess();
    }
    
    // Submit transaction
    return this.submitTransaction(metaTx, gasEstimate);
  }
  
  private async submitTransaction(
    metaTx: MetaTransaction,
    gasLimit: BigNumber
  ): Promise<string> {
    const forwarder = new Contract(
      FORWARDER_ADDRESS,
      FORWARDER_ABI,
      this.wallet
    );
    
    const tx = await forwarder.execute(
      metaTx,
      signature,
      {
        gasLimit,
        gasPrice: await this.getOptimalGasPrice(),
      }
    );
    
    return tx.hash;
  }
}
```

### Batching Optimization

```typescript
export class BatchProcessor {
  async batchProcess(
    transactions: MetaTransaction[]
  ): Promise<string[]> {
    // Group by target contract
    const grouped = this.groupByTarget(transactions);
    
    const results = [];
    
    for (const [target, txs] of grouped) {
      // Create multicall
      const multicall = await this.createMulticall(txs);
      
      // Submit batch
      const txHash = await this.submitBatch(multicall);
      
      results.push(txHash);
    }
    
    return results;
  }
  
  private createMulticall(
    transactions: MetaTransaction[]
  ): MultiCall {
    const calls = transactions.map(tx => ({
      target: tx.to,
      callData: tx.data,
      value: tx.value,
    }));
    
    return {
      calls,
      deadline: Math.max(...transactions.map(tx => tx.deadline)),
    };
  }
}
```

## Cost Management

### Fee Calculation

```typescript
export class FeeCalculator {
  async calculateCost(
    transaction: Transaction
  ): Promise<CostEstimate> {
    // Estimate gas
    const gasLimit = await this.estimateGas(transaction);
    
    // Get current gas price
    const gasPrice = await this.getGasPrice();
    
    // Calculate ETH cost
    const ethCost = gasLimit.mul(gasPrice);
    
    // Get ETH price in USD
    const ethPrice = await this.getETHPrice();
    
    // Calculate USD cost
    const usdCost = ethCost
      .mul(ethPrice)
      .div(BigNumber.from(10).pow(18));
    
    return {
      gasLimit,
      gasPrice,
      ethCost,
      usdCost,
      sponsored: await this.isSponsored(transaction.from),
    };
  }
  
  async shouldSponsor(
    address: string,
    cost: CostEstimate
  ): Promise<boolean> {
    // Check daily limit
    const dailyUsage = await this.getDailyUsage(address);
    
    if (dailyUsage.add(cost.usdCost).gt(DAILY_LIMIT)) {
      return false;
    }
    
    // Check transaction type
    const txType = await this.getTransactionType(transaction);
    
    if (!SPONSORED_TYPES.includes(txType)) {
      return false;
    }
    
    return true;
  }
}
```

### Budget Management

```typescript
export class BudgetManager {
  private dailyBudget = parseEther('10'); // 10 ETH daily
  private monthlyBudget = parseEther('200'); // 200 ETH monthly
  
  async canSponsor(cost: BigNumber): Promise<boolean> {
    const [dailySpent, monthlySpent] = await Promise.all([
      this.getDailySpent(),
      this.getMonthlySpent(),
    ]);
    
    // Check daily limit
    if (dailySpent.add(cost).gt(this.dailyBudget)) {
      return false;
    }
    
    // Check monthly limit
    if (monthlySpent.add(cost).gt(this.monthlyBudget)) {
      return false;
    }
    
    return true;
  }
  
  async recordSpending(
    address: string,
    amount: BigNumber
  ): Promise<void> {
    await db.spending.create({
      address,
      amount: amount.toString(),
      timestamp: Date.now(),
      date: new Date().toISOString().split('T')[0],
    });
    
    // Update caches
    await this.updateDailyCache(amount);
    await this.updateMonthlyCache(amount);
  }
}
```

## UI Integration

### Gasless Status Display

```tsx
export function GaslessStatus() {
  const { address } = useAccount();
  const { data: status } = useGaslessStatus(address);
  
  if (!status) return null;
  
  return (
    <div className="flex items-center gap-2 px-3 py-1 bg-green-100 rounded-lg">
      <CheckCircle className="w-4 h-4 text-green-600" />
      <span className="text-sm text-green-800">
        Gasless enabled
      </span>
      {status.expiresAt && (
        <span className="text-xs text-green-600">
          Expires {formatDate(status.expiresAt)}
        </span>
      )}
    </div>
  );
}
```

### Transaction Confirmation

```tsx
export function TransactionModal({ transaction }: Props) {
  const { isGasless } = useGaslessContext();
  const [sending, setSending] = useState(false);
  
  const handleConfirm = async () => {
    setSending(true);
    
    try {
      if (isGasless) {
        // Submit via gasless relayer
        await gaslessSubmitter.submit(transaction);
      } else {
        // Regular transaction
        await sendTransaction(transaction);
      }
      
      toast.success('Transaction sent!');
    } catch (error) {
      toast.error('Transaction failed');
    } finally {
      setSending(false);
    }
  };
  
  return (
    <Modal>
      <h3>Confirm Transaction</h3>
      
      {isGasless ? (
        <div className="bg-green-50 p-4 rounded-lg">
          <p className="text-green-800">
            This transaction is gasless - no ETH required!
          </p>
        </div>
      ) : (
        <div className="bg-yellow-50 p-4 rounded-lg">
          <p className="text-yellow-800">
            This transaction requires {estimatedGas} ETH
          </p>
        </div>
      )}
      
      <button onClick={handleConfirm} disabled={sending}>
        {sending ? 'Sending...' : 'Confirm'}
      </button>
    </Modal>
  );
}
```

## Monitoring & Analytics

### Usage Tracking

```typescript
export class GaslessAnalytics {
  async trackUsage(): Promise<UsageStats> {
    const stats = await db.gaslessTransactions.aggregate({
      _sum: {
        gasSponsored: true,
      },
      _count: {
        id: true,
      },
      where: {
        timestamp: {
          gte: startOfDay(new Date()),
        },
      },
    });
    
    return {
      transactionCount: stats._count.id,
      totalGasSponsored: stats._sum.gasSponsored,
      uniqueUsers: await this.getUniqueUsers(),
      averageGasPerTx: stats._sum.gasSponsored / stats._count.id,
    };
  }
  
  async generateReport(period: Period): Promise<Report> {
    const data = await this.getDataForPeriod(period);
    
    return {
      totalTransactions: data.length,
      totalCost: this.calculateTotalCost(data),
      topUsers: this.getTopUsers(data),
      transactionTypes: this.groupByType(data),
      savings: this.calculateUserSavings(data),
    };
  }
}
```

### Performance Metrics

```typescript
export class PerformanceMonitor {
  async getMetrics(): Promise<Metrics> {
    return {
      avgProcessingTime: await this.getAvgProcessingTime(),
      successRate: await this.getSuccessRate(),
      queueLength: await this.getQueueLength(),
      relayerBalance: await this.getRelayerBalance(),
    };
  }
  
  async alertOnIssues(): Promise<void> {
    const metrics = await this.getMetrics();
    
    if (metrics.successRate < 0.95) {
      await this.sendAlert('Low success rate detected');
    }
    
    if (metrics.relayerBalance.lt(parseEther('1'))) {
      await this.sendAlert('Relayer balance low');
    }
    
    if (metrics.queueLength > 100) {
      await this.sendAlert('High queue length');
    }
  }
}
```

## Best Practices

### Security
- Always verify signatures
- Implement rate limiting
- Monitor for abuse
- Regular security audits

### Performance
- Batch transactions when possible
- Cache approval status
- Optimize gas estimation
- Use efficient data structures

### User Experience
- Clear gasless status indicators
- Fallback to regular transactions
- Transparent fee structure
- Real-time status updates